#!/usr/bin/python
#-*- coding: utf-8 -*-

import sys
import os
import json
from PIL import Image
import numpy as np

from pylatex import Document, PageStyle, Head, Foot, MiniPage, Section, Subsection, Subsubsection, Command, \
    StandAloneGraphic, MultiColumn, Tabu, LongTabu, LargeText, Tabular, MediumText, LongTable, \
    LineBreak, NewPage, Tabularx, TextColor, simple_page_number, Table, Math
from pylatex.utils import italic, bold, NoEscape
from pylatex.package import Package

from cclib.parser.utils import PeriodicTable

from quchemreport.utils.units import nm_to_wnb
#nm_to_wnb = 10000000.0

def add_row_filter(tab, l, expr='N/A'):
    if ( ((l[1].__class__ != tuple) and (l[1] != expr)) or # case 1
         ((l[1].__class__ == tuple) and np.all([elt != expr for elt in l[1]])) ) : # case 2
        ## case 1 : value is not a tuple AND is not expr (eg. N/A)
        ## case 2 : value is a tuple AND ALL values are different from expr (eg. N/A)
        tab.add_row(l)

def figure_one_col(doc, nomPng, taillePng="7cm", caption="Figure"):
    doc.append(NoEscape(r'\begin{figure}[h]'))
    doc.append(NoEscape(r'\begin{center}'))
    doc.append(NoEscape(r'\includegraphics[width='+taillePng+']{'+nomPng+'}'))
    doc.append(NoEscape(r'\end{center}'))
    doc.append(NoEscape(r'\vspace{-5mm}'))
    doc.append(NoEscape(r'\caption{' + caption + '}'))
    doc.append(NoEscape(r'\end{figure}'))

def figure_two_col(doc, nomPng, nomPng2, taillePng="7cm", caption="Figure"):
    doc.append(NoEscape(r'\begin{figure}[h]'))
    doc.append(NoEscape(r'\begin{center}'))
    doc.append(NoEscape(r'\includegraphics[width='+taillePng+']{'+nomPng+'}'))
    doc.append(NoEscape(r'\includegraphics[width='+taillePng+']{'+nomPng2+'}'))
    doc.append(NoEscape(r'\end{center}'))
    doc.append(NoEscape(r'\vspace{-5mm}'))
    doc.append(NoEscape(r'\caption{' + caption + '}'))
    doc.append(NoEscape(r'\end{figure}'))


def json2latex(args, json_list, data, mode="clean"):
    
    # 3 report types are considered. 
    # Full report have an original layout. Pretty but inappropiate for pdf2word conversion.
    # They will print all considered data and needs discretization process: Full log verbosity. Orbkit calculations. 
    # SI mode will discard the layout. Better for the Supplementary inofrmation generation througth a pdf 2word conversion
    # SI mode will also not print the Fukui values and pictures, Analysis populations, Excited states dipoles. 
    # text mode reports are the most simple ones and discard all discretization pictures and calculations
    # Based on the SI mode, we remove the FMO, EDD pictures, CDFT and Charge transfer data.
    report_type = args['mode']
    
    # Get data 
    data_ref = data['data_for_discretization']
    job_types = data['job_types']

    # Report name file
    name = data_ref["molecule"]["formula"]
    dirname = os.path.basename(os.getcwd())
    rapFile = (dirname + "_" + report_type + "_report")
     
    #####################################################################
    #                                                                   #
    ## production du rapport en .tex                                 #
    #                                                                   #
    #####################################################################
    
    ### create document and import needed packages
    
    doc = Document(documentclass="article",font_size='small',geometry_options='a4paper, left=15mm, right=15mm, top=15mm, bottom=15mm')
    # packages
    doc.packages.append(NoEscape(r'\usepackage{xcolor}'))
    doc.packages.append(NoEscape(r'\usepackage{longtable}'))
    doc.packages.append(NoEscape(r'\usepackage{graphicx}'))
    # For full report, definition of an original layout. 
    if report_type == 'full': 
        doc.packages.append(NoEscape(r'\usepackage{titlesec}'))
        doc.packages.append(Package('datetime'))
        doc.packages.append(NoEscape(r'\usepackage{extramarks}'))
        doc.packages.append(NoEscape(r'\usepackage{fancyhdr}'))
        doc.packages.append(NoEscape(r'\pagestyle{fancy}'))
        doc.packages.append(NoEscape(r'\fancyhf{}'))
        # define header / footer texts
        doc.packages.append(NoEscape(r'\lhead{MOLECULAR CALCULATION REPORT}'))
        doc.packages.append(NoEscape(r'\rhead{Generated by quchemreport}'))
        doc.packages.append(NoEscape(r'\lfoot{\today ~  \currenttime}'))
        doc.packages.append(NoEscape(r'\rfoot{Page \thepage}'))
        doc.packages.append(NoEscape(r'\cfoot{}'))
        # redefine rules for header / footer
        doc.packages.append(NoEscape(r'\renewcommand\headrulewidth{0.4pt}'))
        doc.packages.append(NoEscape(r'\renewcommand\footrulewidth{0.4pt}'))
        # redefine section
        doc.packages.append(NoEscape(r'\definecolor{ufrblue}{RGB}{0,161,140}'))
        doc.packages.append(NoEscape(r'\definecolor{bordeau}{RGB}{125,31,31}'))
        doc.packages.append(NoEscape(r'\titleformat{name=\section}[block]{\sc\large}{}{0pt}{\colorsection}'))
        doc.packages.append(NoEscape(r'\titlespacing{\section}{0pt}{\baselineskip}{2pt}'))
        doc.packages.append(NoEscape(r'\titlespacing{\subsection}{4pt}{\baselineskip}{0pt}'))
        doc.packages.append(NoEscape(r'\newcommand{\colorsection}[1]{'+
                                     r'\colorbox{ufrblue}{\parbox{\dimexpr\textwidth-2\fboxsep}{\textcolor{white}{'+
                                     r'\textbf{{\thesection.\ #1}}}}}}'))
     
    # For non full report, definition of a simple Title. 
    # SI mode is more suitable to conversion to word for supp Info generation. 
    if report_type != 'full': 
        doc.append(NoEscape(r'\begin{center}'))
        doc.append(LargeText(bold("Molecular Calculation Report generated by quchemreport \n")))
        doc.append(NoEscape(r'\today '))
        doc.append(NoEscape(r'\end{center}'))

    ### section 1 : molecule description
    #########################################
    with doc.create(Section('MOLECULE')) :
        nomPng = "img-TOPOLOGY.png"
        nomPng2 = "img-TOPOLOGY_cam2.png"
        if (os.path.isfile(nomPng)) :
            if (os.path.isfile(nomPng2)) :
                figure_two_col(doc, nomPng, nomPng2, caption="Chemical structure diagram with atomic numbering from two points of view.")
            else:
                figure_one_col(doc, nomPng, caption="Chemical structure diagram with atomic numbering.")
    
        
        with doc.create(LongTabu("X[1,l] X[4,l]")) as mol_table:
            inchi = (data_ref["molecule"]["inchi"]).rstrip().split("=")[-1]
            mol_table.add_row(['Directory name', dirname ])
            mol_table.add_row(['Formula', data_ref["molecule"]["formula"] ])
            mol_table.add_row(['Charge', data_ref["molecule"]["charge"] ])
            mol_table.add_row(['Spin multiplicity', data_ref["molecule"]["multiplicity"] ])    
            # For full report, more data will be printed 
            if report_type == 'full': 
                mol_table.add_row(['Monoisotopic mass', "%.5f Da" % data_ref["molecule"]["monoisotopic_mass"]])
                mol_table.add_row(['InChI'  , inchi ])
                if (len(data_ref["molecule"]["smi"]) < 80):
                    mol_table.add_row(['SMILES' , data_ref["molecule"]["smi"] ])
    
    ### section 2 : computational details Common for all report types   
    #########################################
    with doc.create(Section('COMPUTATIONAL DETAILS')) :
        with doc.create(LongTabu("X[3,l] X[1,l] X[1,l]")) as param_table :
            software = data_ref["comp_details"]["general"]["package"]
            try : param_table.add_row(['Software'  , 
                                 data_ref["comp_details"]["general"]["package"], '(' + 
                                 data_ref["comp_details"]["general"]["package_version"] + ')' ] )
            except KeyError :
                pass
            param_table.add_row(['Computational method', 
                                 data_ref["comp_details"]["general"]["last_theory"], " " ])
            add_row_filter(param_table, ['Functional', 
                                         data_ref["comp_details"]["general"]["functional"], " " ]) 
            try : add_row_filter(param_table, ['Basis set name', 
                                         data_ref["comp_details"]["general"]["basis_set_name"], " " ])
            except KeyError :
                pass
            param_table.add_row(['Number of basis set functions', 
                                 data_ref["comp_details"]["general"]["basis_set_size"], " " ])
            param_table.add_row(['Closed shell calculation', 
                                 data_ref["comp_details"]["general"]["is_closed_shell"], " " ])
            try : add_row_filter(param_table, ['Integration grid', 
                                         data_ref["comp_details"]["general"]["integration_grid"], " " ])
            except KeyError :
                pass
            try : add_row_filter(param_table, ['Solvent', 
                                         data_ref["comp_details"]["general"]["solvent"], " " ])
            except KeyError :
                pass
#            TODO 
#            add_row_filter(param_table, ['Solvent reaction filed method',  
#                                         json_list[i]["comp_details"]["general"]["solvent_reaction_field"]])
    
            scfTargets = data_ref["comp_details"]["general"]["scf_targets"][-1]
            if software=="Gaussian" : # Gaussian or GAUSSIAN (upper/lower?
                param_table.add_row(["Requested SCF convergence on RMS and Max density matrix", scfTargets[0], scfTargets[1]  ])
                param_table.add_row(["Requested SCF convergence on energy", scfTargets[2], " "  ])
            if software=="GAMESS" :
                param_table.add_row(["Requested SCF convergence on density", scfTargets[0], " "   ])

            #Specific calculations parameters :
            OPT_param_print = False
            for i,jsonfile in enumerate(json_list):
                #OPT calculation parameters :
                if ((job_types[i] == ['OPT']) or  (job_types[i]== ['FREQ', 'OPT'])) and (OPT_param_print == False) :
                    param_table.add_row([" ", " " , " "])
                    k = 0
                    j = str(k+1)
                    try:                       
                        param_table.add_row(["Job type: Geometry optimization", " " , " "])
                        geomTargets = json_list[i]["comp_details"]["geometry"]["geometric_targets"]
                        geomValues = json_list[i]["results"]['geometry']['geometric_values'][-1]
                        if software=="Gaussian": # Gaussian or GAUSSIAN (upper/lower?
                            param_table.add_row(["Max Force value and threshold", "%.6f" % geomValues[0], "%.6f" % geomTargets[0]])
                            param_table.add_row(["RMS Force value and threshold", "%.6f" % geomValues[1] ,  "%.6f" % geomTargets[1]])
                            param_table.add_row(["Max Displacement value and threshold", "%.6f" % geomValues[2] , "%.6f" % geomTargets[2]])
                            param_table.add_row(["RMS Displacement value and threshold", "%.6f" % geomValues[3] , "%.6f" % geomTargets[3]])
                            OPT_param_print = True # to prevent repetition of data from OPT and FREQ
                        if software=="GAMESS" :
                            # in Hartrees per Bohr
                            param_table.add_row(["Max Force value and threshold", geomValues[0] , geomTargets[0]])
                            param_table.add_row(["RMS Force value and threshold",  geomValues[1] , geomTargets[1]])    
                    except:
                        pass 
                #FREQ calculation parameters :  
                if job_types[i] == ['FREQ'] or job_types[i]== ['FREQ', 'OPT'] or job_types[i]== ['FREQ', 'OPT', 'TD'] :
                    k = 0
                    j =str(k+1)
                    param_table.add_row(["Job type: Frequency and thermochemical analysis", " ", " "])
                    try:
                        add_row_filter(param_table, ['Temperature', 
                                                 "%.2f K" % json_list[i]["comp_details"]["freq"]["temperature"] , "  " ])
                    except:
                        pass
                    T_len = False
                    try : len(json_list[i]["comp_details"]["freq"]["temperature"]) 
                    except KeyError :
                        json_list[i]["comp_details"]["freq"]["temperature"] = []
                    except TypeError :
                        T_len = True
                        if T_len is True :
                             try : add_row_filter(param_table, ['Anharmonic effects', 
                                                     json_list[i]["comp_details"]["freq"]["anharmonicity"], "  "])                        
                             except KeyError :
                                    pass
                    if (json_list[i]["comp_details"]["freq"]["temperature"]) != [] :
                        try : add_row_filter(param_table, ['Anharmonic effects', 
                                                     json_list[i]["comp_details"]["freq"]["anharmonicity"], "  "])                        
                        except KeyError :
                            pass               
                #TD calculation parameters :          
                if job_types[i] == ['TD'] or job_types[i]== ['FREQ', 'OPT', 'TD']:
                    k = 0
                    j =str(k+1)
                    param_table.add_row(["Job type: Time-dependent calculation", " " , " "])
                    try :  param_table.add_row(['Number of calculated excited states and spin state'  , 
                                                 json_list[i]["comp_details"]["excited_states"]["nb_et_states"], np.unique(json_list[i]["results"]["excited_states"]["et_sym"]) ])
                    except KeyError :
                         pass
                param_table.add_row([" ", " " , " "])
                                      
        
    ### section 3 : results
    #########################################
    with doc.create(Section('RESULTS')) : 
        with doc.create(LongTabu("X[3,l] X[1,l] X[1,l]")) as res_table :
            #Common results / wavefunction :
            res_table.add_row(['Total molecular energy', "%.5f hartrees" %
                                     data_ref["results"]["wavefunction"]["total_molecular_energy"], " " ])
            homo_ind = data_ref["results"]["wavefunction"]["homo_indexes"]
            MO_energies = data_ref["results"]["wavefunction"]["MO_energies"]
            if len(homo_ind) == 2:
                # Unrestricted calculation: two columns of MO energies
                res_table.add_row(['Unrestricted calculation', 'Alpha spin MO', 'Beta spin MO' ]) # indices begin at 0, remove brackets
                res_table.add_row(['HOMO number', homo_ind[0]+1, homo_ind[1]+1  ]) 
                res_table.add_row(['LUMO+1 energies', "%.2f eV" % MO_energies[0][homo_ind[0]+2], "%.2f eV" % MO_energies[1][homo_ind[1]+2] ]) 
                res_table.add_row(['LUMO   energies', "%.2f eV" % MO_energies[0][homo_ind[0]+1], "%.2f eV" % MO_energies[1][homo_ind[1]+1]  ]) 
                res_table.add_row(['HOMO   energies', "%.2f eV" % MO_energies[0][homo_ind[0]],  "%.2f eV" % MO_energies[1][homo_ind[1]] ]) 
                res_table.add_row(['HOMO-1 energies', "%.2f eV" % MO_energies[0][homo_ind[0]-1], "%.2f eV" % MO_energies[1][homo_ind[1]-1] ]) 
            else:
                res_table.add_row(['HOMO number', homo_ind[0]+1, " "  ]) 
                res_table.add_row(['LUMO+1 energies', "%.2f eV" % MO_energies[0][homo_ind[0]+2], " " ]) 
                res_table.add_row(['LUMO   energies', "%.2f eV" % MO_energies[0][homo_ind[0]+1], " "  ]) 
                res_table.add_row(['HOMO   energies', "%.2f eV" % MO_energies[0][homo_ind[0]],  " " ]) 
                res_table.add_row(['HOMO-1 energies', "%.2f eV" % MO_energies[0][homo_ind[0]-1], " " ]) 

            # CDFT Indices  table only in full report
            if report_type == 'full': 
                res_table.add_row([" ", " " , " "])
                try : res_table.add_row(['CDFT indices: Electron Affinity', "%.4f hartrees" % data_ref["results"]["wavefunction"]["A"] , ""  ] )
                except KeyError :
                    pass
                try : res_table.add_row(['CDFT indices: Ionisation Potential', "%.4f hartrees" % data_ref["results"]["wavefunction"]["I"] , ""  ] )
                except KeyError :
                    pass
                try : res_table.add_row(['CDFT indices: Electronegativity', "%.4f hartrees" % data_ref["results"]["wavefunction"]["Khi"] , ""  ] )
                except KeyError :
                    pass
                try : res_table.add_row(['CDFT indices: Hardness', "%.4f hartrees" % data_ref["results"]["wavefunction"]["Eta"] , ""  ] )
                except KeyError :
                    pass
                try : res_table.add_row(['CDFT indices: Electrophilicity', "%.4f " % data_ref["results"]["wavefunction"]["Omega"] , ""  ] )
                except KeyError :
                    pass
                try : res_table.add_row(['CDFT indices: Electron-flow', "%.4f e-" % data_ref["results"]["wavefunction"]["DeltaN"], ""  ] )
                except KeyError :
                    pass
                       
            #Specific calculations results:      
            OPT_res_print = False
            for i,jsonfile in enumerate(json_list):          
                #OPT calculation results:
                if ((job_types[i] == ['OPT']) or  (job_types[i] == ['FREQ', 'OPT']) \
                              or job_types[i]== ['FREQ', 'OPT', 'TD']) and (OPT_res_print == False) :
                    j = str(i+1)
                    OPT_res_print = True # to prevent repetition from OPT and FREQ
                    res_table.add_row([" ", " " , " "])
                    res_table.add_row(["Geometry optimization specific results", " " , " "])
                    res_table.add_row(['Converged nuclear repulsion energy', "%.5f Hartrees" % json_list[i]["results"]["geometry"]["nuclear_repulsion_energy_from_xyz"], " "])

                #FREQ calculation results:
                if job_types[i] == ['FREQ'] or  job_types[i]== ['FREQ', 'OPT'] or job_types[i]== ['FREQ', 'OPT', 'TD'] :
                    k = 0
                    j =str(k+1)
                    res_table.add_row([" ", " " , " "])
                    res_table.add_row(["Frequency and Thermochemistry specific results", " " , " "])
                    try : rtemper = json_list[i]["comp_details"]["freq"]["temperature"]
                    except KeyError :
                         rtemper = []
                    # ND-arrays
                    try : vibrational_int = np.array(json_list[i]["results"]["freq"]["vibrational_int"])
                    except KeyError :
                        vibrational_int = []
                    try : vibrational_freq = np.array(json_list[i]["results"]["freq"]["vibrational_freq"])
                    except KeyError : vibrational_freq = []
                      
                    if len(vibrational_int) == 0 :
                        vibrational_int = []
                    else :  
                        # Print number of negative frequencies   
                        nb_negatives = np.sum(vibrational_freq < 0, axis=0)
          
                    if (len(vibrational_int) != 0) and (rtemper != "N/A") :
                        if "zero_point_energy" in json_list[i]["results"]["freq"] :
                            res_table.add_row(['Sum of electronic and zero-point energy', 
                                               "%.5f Hartrees" % json_list[i]["results"]["freq"]["zero_point_energy"], " "])
                        if "electronic_thermal_energy" in json_list[i]["results"]["freq"] :
                            res_table.add_row(["Sum of electronic and thermal energies at  %.2f K"  % rtemper, 
                                               "%.5f Hartrees" % json_list[i]["results"]["freq"]["electronic_thermal_energy"], " "])
                        if "enthalpy" in json_list[i]["results"]["freq"] :
                            res_table.add_row(["Enthalpy at %.2f K" % rtemper,
                                               "%.5f Hartrees" % json_list[i]["results"]["freq"]["enthalpy"], " "])
                        if "free_energy" in json_list[i]["results"]["freq"] :
                            res_table.add_row(["Gibbs free energy at %.2f K" % rtemper,
                                               "%.5f Hartrees" % json_list[i]["results"]["freq"]["free_energy"], " "])
                        if "entropy" in json_list[i]["results"]["freq"] :
                            res_table.add_row(["Entropy at %.2f K" % rtemper, 
                                               "%.5f Hartrees" % json_list[i]["results"]["freq"]["entropy"], " "])
        # End of the big common result table. 

        ## List of tables that are not job associated but dependent of data_ref. 
        # Population analysis tables and Fukui condensed values table only in full reports
        if report_type == 'full': 
            # Mulliken partial charges table
            try : mulliken = data_ref["results"]["wavefunction"]["Mulliken_partial_charges"]
            except KeyError :
                mulliken = []
            # test other population analysis
            try : hirsh = data_ref["results"]["wavefunction"]["Hirshfeld_partial_charges"]
            except KeyError :
                hirsh = []
            try : cm5 = data_ref["results"]["wavefunction"]["CM5_partial_charges"]
            except KeyError :
                cm5 = []
            if len(mulliken) != 0 :
                # only Mulliken analysis
                mulliken = np.array(mulliken)
                mean_m = np.mean(mulliken)
                dev_m = np.std(mulliken)
                thres_max = mean_m + dev_m
                thres_min = mean_m - dev_m
                if (len(hirsh) == 0) and (len(cm5) == 0):
                    ind = np.argsort(mulliken)
                    res_table.add_row([" ", " " , " "])
                    res_table.add_row(['Mean Mulliken atomic charge and standard deviation', "%.4f e-" % mean_m , "%.4f e-" % dev_m  ])
                    res_table.add_row(['Atoms with negatives charges under the standard deviation', "NÂ°" , "Mulliken charge"  ])
                    for ielt in ind :
                        if (mulliken[ielt] < thres_min) :
                            res_table.add_row([ " " , "%s %d" %(PeriodicTable().element[json_list[i]['molecule']["atoms_Z"][ielt]], (1+ielt)), "  %.3f" % mulliken[ielt] ])
                    res_table.add_row(['Atoms with positives charges over the standard deviation', "NÂ°" , "Mulliken charge"  ])
                    for ielt in ind :                
                        if (mulliken[ielt] > thres_max) :
                            res_table.add_row([ " " , "%s %d" %(PeriodicTable().element[json_list[i]['molecule']["atoms_Z"][ielt]], (1+ielt)), "  %+.3f" % mulliken[ielt] ])           
                elif (len(hirsh) != 0) and (len(cm5) == 0):
                    # Hirshfeld but no CM5 partial charges table
                    hirsh = np.array(hirsh)
                    mean_h = np.mean(hirsh)
                    dev_h = np.std(hirsh)
                    thres_max = mean_h + dev_h
                    thres_min = mean_h - dev_h
                    ind = np.argsort(hirsh)                
                    res_table.add_row([" ", " " , " "])
                    doc.append(NoEscape(r'\begin{center}'))
                    with doc.create(Tabular('rlrr')) as tableau :
                        row_cells = [MultiColumn(4, align='c', 
                                                     data="Table. Atomic charges population analysis. Selection of the most charged atoms based on Hirshfeld analysis")]
                        tableau.add_row(row_cells)
                        tableau.add_row(["", "Atom and NÂ°", "Hirshfeld charge", "Mulliken charge"])
                        tableau.add_hline()
                        for ielt in ind :
                            if (hirsh[ielt] < thres_min) :
                                tableau.add_row(["",
                                                 "%s %d" %(PeriodicTable().element[json_list[i]['molecule']["atoms_Z"][ielt]], (1+ielt)),
                                                 "  %+.3f" % hirsh[ielt] ,
                                                 "  %+.3f" % mulliken[ielt]   ])
                        for ielt in ind :
                            if (hirsh[ielt] > thres_max) :
                                tableau.add_row(["",
                                                 "%s %d" %(PeriodicTable().element[json_list[i]['molecule']["atoms_Z"][ielt]], (1+ielt)),
                                                 "  %+.3f" % hirsh[ielt] ,
                                                 "  %+.3f" % mulliken[ielt]   ])
                        tableau.add_hline()
                    doc.append(NoEscape(r'\end{center}'))

                elif (len(hirsh) != 0) and (len(cm5) != 0):
                    # Hirshfeld and CM5 partial charges table
                    cm5 = np.array(cm5)
                    mean_h = np.mean(cm5)
                    dev_h = np.std(cm5)
                    thres_max = mean_h + dev_h
                    thres_min = mean_h - dev_h
                    ind = np.argsort(cm5)                
                    res_table.add_row([" ", " " , " "])
                    doc.append(NoEscape(r'\begin{center}'))
                    with doc.create(Tabular('rlrrr')) as tableau :
                        row_cells = [MultiColumn(5, align='c', 
                                                     data="Table. Atomic charges population analysis. Selection of the most charged atoms based on Hirshfeld analysis")]
                        tableau.add_row(row_cells)
                        tableau.add_row(["", "Atom and NÂ°", "Hirshfeld charge", "CM5 charge", "Mulliken charge"])
                        tableau.add_hline()
                        for ielt in ind :
                            if (cm5[ielt] < thres_min) :
                                tableau.add_row(["",
                                                 "%s %d" %(PeriodicTable().element[json_list[i]['molecule']["atoms_Z"][ielt]], (1+ielt)),
                                                 "  %+.3f" % cm5[ielt] , 
                                                 "  %+.3f" % hirsh[ielt] ,
                                                 "  %+.3f" % mulliken[ielt]   ])
                        for ielt in ind :
                            if (cm5[ielt] > thres_max) :
                                tableau.add_row(["",
                                                 "%s %d" %(PeriodicTable().element[json_list[i]['molecule']["atoms_Z"][ielt]], (1+ielt)),
                                                 "  %+.3f" % cm5[ielt] , 
                                                 "  %+.3f" % hirsh[ielt] ,
                                                 "  %+.3f" % mulliken[ielt]   ])
                        tableau.add_hline()
                    doc.append(NoEscape(r'\end{center}'))

            # Fukui condensed values table
            try : fplus_lambda_mulliken = data_ref["results"]["wavefunction"]["fplus_lambda_mulliken"]
            except KeyError :
                fplus_lambda_mulliken = []
            try : fminus_lambda_mulliken = data_ref["results"]["wavefunction"]["fminus_lambda_mulliken"]
            except KeyError :
                fminus_lambda_mulliken = []
            try : fdual_lambda_mulliken = data_ref["results"]["wavefunction"]["fdual_lambda_mulliken"]
            except KeyError :
                fdual_lambda_mulliken = []
            # Fukui condensed values table, check for Hirshfeld values. If present, use them instead.
            try : fplus_lambda_hirshfeld = data_ref["results"]["wavefunction"]["fplus_lambda_hirshfeld"]
            except KeyError :
                fplus_lambda_hirshfeld = []
            try : fminus_lambda_hirshfeld = data_ref["results"]["wavefunction"]["fminus_lambda_hirshfeld"]
            except KeyError :
                fminus_lambda_hirshfeld = []
            try : fdual_lambda_hirshfeld = data_ref["results"]["wavefunction"]["fdual_lambda_hirshfeld"]
            except KeyError :
                fdual_lambda_hirshfeld = []
            # Test if Fdual is available. If not Table is not mandatory.
            if len(fdual_lambda_hirshfeld) > 0 :
                fdual_lambda_hirshfeld = np.array(fdual_lambda_hirshfeld)
                mean_fd = np.mean(fdual_lambda_hirshfeld)
                dev_fd = np.std(fdual_lambda_hirshfeld)
                thres_max = mean_fd + dev_fd
                thres_min = mean_fd - dev_fd
                ind = np.argsort(fdual_lambda_hirshfeld)
                doc.append(NoEscape(r'\begin{center}'))
                with doc.create(Tabular('p{0cm}rrrrp{0cm}')) as tableau :
                    row_cells = [MultiColumn(6, align='c', 
                                             data="Table. Selection of the most important condensed Fukui functions based on Hirshfeld charges. ")]
                    tableau.add_row(row_cells)
                    tableau.add_row(["", "Atom", "atomic dual descriptor (f+ - f-)", "atomic electrophilicity f+", "atomic nucleophilicity f-", ""])
                    tableau.add_hline()
                    for ielt in ind :
                        if (fdual_lambda_hirshfeld[ielt] < thres_min) :
                            tableau.add_row(["", "%s %d" %(PeriodicTable().element[json_list[i]['molecule']["atoms_Z"][ielt]], (1+ielt)),
                                             "  %.2f" % fdual_lambda_hirshfeld[ielt], 
                                             "  %.2f" % fplus_lambda_hirshfeld[ielt], 
                                             "  %.2f" % fminus_lambda_hirshfeld[ielt],
                                               ""])
                    for ielt in ind :
                        if (fdual_lambda_hirshfeld[ielt] > thres_max) :
                            tableau.add_row(["", "%s %d" %(PeriodicTable().element[json_list[i]['molecule']["atoms_Z"][ielt]], (1+ielt)),
                                             "  %.2f" % fdual_lambda_hirshfeld[ielt], 
                                             "  %.2f" % fplus_lambda_hirshfeld[ielt], 
                                             "  %.2f" % fminus_lambda_hirshfeld[ielt],
                                               ""])
                    tableau.add_hline()
                doc.append(NoEscape(r'\end{center}'))
            # Test if Fdual Hirshfeld is not available check for Mulliken one. If not Table is not mandatory.
            elif len(fdual_lambda_mulliken) > 0 :
                fdual_lambda_mulliken = np.array(fdual_lambda_mulliken)
                mean_fd = np.mean(fdual_lambda_mulliken)
                dev_fd = np.std(fdual_lambda_mulliken)
                thres_max = mean_fd + dev_fd
                thres_min = mean_fd - dev_fd
                ind = np.argsort(fdual_lambda_mulliken)
                doc.append(NoEscape(r'\begin{center}'))
                with doc.create(Tabular('p{0cm}rrrrp{0cm}')) as tableau :
                    row_cells = [MultiColumn(6, align='c', 
                                             data="Table. Selection of the most important condensed Fukui functions based on Mulliken charges. ")]
                    tableau.add_row(row_cells)
                    tableau.add_row(["", "Atom", "atomic dual descriptor (f+ - f-)", "atomic electrophilicity f+", "atomic nucleophilicity f-", ""])
                    tableau.add_hline()
                    for ielt in ind :
                        if (fdual_lambda_mulliken[ielt] < thres_min) :
                            tableau.add_row(["", "%s %d" %(PeriodicTable().element[json_list[i]['molecule']["atoms_Z"][ielt]], (1+ielt)),
                                             "  %.2f" % fdual_lambda_mulliken[ielt], 
                                             "  %.2f" % fplus_lambda_mulliken[ielt], 
                                             "  %.2f" % fminus_lambda_mulliken[ielt],
                                               ""])
                    for ielt in ind :
                        if (fdual_lambda_mulliken[ielt] > thres_max) :
                            tableau.add_row(["", "%s %d" %(PeriodicTable().element[json_list[i]['molecule']["atoms_Z"][ielt]], (1+ielt)),
                                             "  %.2f" % fdual_lambda_mulliken[ielt], 
                                             "  %.2f" % fplus_lambda_mulliken[ielt], 
                                             "  %.2f" % fminus_lambda_mulliken[ielt],
                                               ""])
                    tableau.add_hline()
                doc.append(NoEscape(r'\end{center}'))

        ## List of figures. Beware insertion based on files. Should be given through arguments!    
        # figure with MO not available in text report type
        if report_type != 'text':
            # Test if calculation is unrestricted (alpha and beta spin electrons)
            if len(homo_ind) == 2:
                # Unrestricted calculation: treat the alpha orbitals first
                nomPng = "img-MO-homo_alpha.png"
                nomPng2 = "img-MO-homo_beta.png"                                                        
                nomPng3 = "img-MO-lumo_alpha.png"
                nomPng4 = "img-MO-lumo_beta.png"                                                        
                if (os.path.isfile(nomPng)) :
                    if (os.path.isfile(nomPng2)) :
                        figure_two_col(doc, nomPng, nomPng2, caption="Representation of the HOMO of spin alpha (left) and spin beta (right).")
                        if (os.path.isfile(nomPng3)) :
                            if (os.path.isfile(nomPng4)) :
                                figure_two_col(doc, nomPng3, nomPng4, caption="Representation of the LUMO of spin alpha (left) and spin beta (right).")
                    elif (os.path.isfile(nomPng3)) :
                        figure_two_col(doc, nomPng, nomPng3, caption="Representation of the Frontier Molecular Orbitals HOMO (left) and LUMO (right) of spin alpha.")
            # For restricted calculation print HOMO and LUMO and use two cameras instead
            else:
                nomPng = "img-MO-homo.png"
                nomPng2 = "img-MO-homo_cam2.png"                                                        
                nomPng3 = "img-MO-lumo.png"
                nomPng4 = "img-MO-lumo_cam2.png"                                                        
                if (os.path.isfile(nomPng)) :
                    if (os.path.isfile(nomPng2)) :
                        figure_two_col(doc, nomPng, nomPng2, caption="Representation of the HOMO from two points of view.")
                        if (os.path.isfile(nomPng3)) :
                            if (os.path.isfile(nomPng4)) :
                                figure_two_col(doc, nomPng3, nomPng4, caption="Representation of the LUMO from two points of view.")
                    elif (os.path.isfile(nomPng3)) :
                        figure_two_col(doc, nomPng, nomPng3, caption="Representation of the Frontier Molecular Orbitals HOMO (left) and LUMO (right).")
            
        # Figures of that are only printed in full type report 
        if report_type == 'full':
            # figures of Fukui functions if calculated
            nomPng = "img-fukui-SP_plus.png"
            nomPng2 = "img-fukui-SP_plus_cam2.png"                                                        
            nomPng3 = "img-fukui-SP_minus.png"
            nomPng4 = "img-fukui-SP_minus_cam2.png"                                                        
            if (os.path.isfile(nomPng)) :
                if (os.path.isfile(nomPng2)) :
                    figure_two_col(doc, nomPng, nomPng2, caption="Representation of the F+ function from two points of view. The Blue color indicate the most electrophilic regions.")
                    if (os.path.isfile(nomPng3)) :
                        if (os.path.isfile(nomPng4)) :
                            figure_two_col(doc, nomPng3, nomPng4, caption="Representation of the F- function from two points of view. The Blue color indicate the most nucleophilic regions.")
                elif (os.path.isfile(nomPng3)) :
                    figure_two_col(doc, nomPng, nomPng3, caption="Representation of the electrophilic (left) and nucleophilic (right) fukui functions.")
            nomPng = "img-Fdual.png"
            nomPng2 = "img-Fdual_cam2.png"                                                        
            if (os.path.isfile(nomPng)) :
                if (os.path.isfile(nomPng2)) :
                    figure_two_col(doc, nomPng, nomPng2, caption="Representation of the Dual descriptor from two points of view. Electrophilic and nucleophilic regions correspond to blue and white surfaces.")
                elif (os.path.isfile(nomPng3)) :
                    figure_two_col(doc, nomPng, nomPng2, 
                      caption="Representation of the Dual descriptor. Electrophilic and nucleophilic regions correspond to blue and white surfaces.")
        
            # figure with ESP
            nomPng = "img-MEP_fixed.png"
            nomPng2 = "img-MEP.png"                                                        
            if (os.path.isfile(nomPng)) :
                if (os.path.isfile(nomPng2)) :
                    figure_two_col(doc, nomPng, nomPng2, caption="Representations of the Molecular Electrostatic Potential mapped on the electron density (cutoff value of 0.002 e-/bohr3). On the left, red, blue and green regions correspond to negative values < -0.06 a.u., positive values > 0.08 a.u. and neutral values respectively. On the right, the scale is set automatically to highlight the minimum values in red and the maximum values in blues.")
                elif ( not os.path.isfile(nomPng2)) :
                    figure_one_col(doc, nomPng, taillePng="10cm", 
                    caption="Representations of the Molecular Electrostatic Potential mapped on the electron density (cutoff value of 0.002 e-/bohr3). On the left, red, blue and green regions correspond to negative values < -0.06 a.u., positive values > 0.08 a.u. and neutral values respectively.")

            # External picture generated by AIMAll
            nomPng = "img-AIM-BCP-rho.png"
            if (not os.path.isfile(nomPng)) :
                print(nomPng+" not found. It can not be added to the report.\n")
            else:
                figure_one_col(doc, nomPng, taillePng="10cm", 
                      caption="Electron density value at each of the bond critical points calculated with the AIMAll program.")
                    
        # Specific OPT and FREQ report tables 
        for i,jsonfile in enumerate(json_list):          
            # Normal modes table                                                       
            if job_types[i] == ['FREQ'] or  job_types[i]== ['FREQ', 'OPT'] or job_types[i]== ['FREQ', 'OPT', 'TD'] :
                k = 0
                try : vibrational_int = np.array(json_list[i]["results"]["freq"]["vibrational_int"])
                except KeyError :
                    vibrational_int = []
                try : vibrational_freq = np.array(json_list[i]["results"]["freq"]["vibrational_freq"])
                except KeyError : vibrational_freq = []              
                try : vibrational_sym = np.array(json_list[i]["results"]["freq"]["vibrational_sym"])
                except KeyError :
                    vibrational_sym = np.array(["N/A" for _ in range(len(vibrational_int))])
                doc.append(NoEscape(r'\begin{center}'))
                # filtering & orderering
                if len(vibrational_int) == 0 :
                    vibrational_int = []
                else :  
                    vib_filter = vibrational_int > 50.
                    vib_order = np.argsort(vibrational_freq[vib_filter])[::-1]
                    vibrational_int = vibrational_int[vib_filter][vib_order]
                    vibrational_freq = vibrational_freq[vib_filter][vib_order]
                    vibrational_sym = vibrational_sym[vib_filter][vib_order]
                with doc.create(Tabular('rrrc')) as tableau :
                    row_cells = [MultiColumn(4, align='c', 
                                                 data="Table. Most intense (> 50 km/mol) molecular vibrations in wavenumbers")]
                    tableau.add_row(row_cells)
                    tableau.add_row(["", "Frequencies", "Intensity", "Symmetry"])
                    tableau.add_hline()
                    for k in range(len(vibrational_freq)) :
                        tableau.add_row(["",
                                         "%d" % vibrational_freq[k],
                                         "%d" % vibrational_int[k], 
                                         vibrational_sym[k]])
                    tableau.add_hline()
                doc.append(NoEscape(r'\end{center}'))
        
            #TD calculation results :                
            if job_types[i] == ['TD'] or job_types[i]== ['FREQ', 'OPT', 'TD'] :                        
                j =str(i+1)
                try : et_energies = json_list[i]["results"]["excited_states"]["et_energies"]
                except KeyError :
                    et_energies = []
                # Conversion of wavenumbers to nm    
                et_nm = [nm_to_wnb / x for x in et_energies]
                rnbExci = len(et_energies)                            
                if rnbExci != 0 and et_energies != 'N/A':
                    doc.append(NoEscape(r'\begin{center}'))
                    # 2 kind of table including the charge transfer data when discretization is done (SI and Full)    
                    if report_type == 'text':
                        with doc.create(Tabular('rrrrrrp{6cm}')) as td_tabu :
                            if rnbExci < 21 :
                                row_cells = [MultiColumn(7, align='c', 
                                                         data="Table. Results concerning the calculated mono-electronic excitations.")]
                                td_selection = 0                               
                            else : # select the excited states when there is more than 20 calculated excited states. 
                                row_cells = [MultiColumn(7, align='c', 
                                                         data="Table. First five calculated mono-electronic excitations and those with f > 0.1 or R > 10."
                                                         )]
                                td_selection = 1                               
                            td_tabu.add_row(row_cells)
                            td_tabu.add_row([ "E.S.", "Symmetry", " nm ", NoEscape(r"cm$^{-1}$") , 
                                             italic("f"), "R", "Excitation description : initial OM - ending OM (% if > 5%)"])
                            td_tabu.add_hline()
                            for j in range(rnbExci) :
                                try : etr_i = json_list[i]["results"]["excited_states"]["et_rot"][j]
                                except KeyError :
                                    etr_i = 0. 
                                trans = json_list[i]["results"]["excited_states"]["et_transitions"][j]
                                # Form the string description of the escitation. Based on MO init -> MO end (%coeff)
                                CIS = " "
                                for subtrans, ST in enumerate(trans):
                                    coeff = int(ST[2]**2*100)
                                    if coeff > 5. : 
                                        if len(homo_ind) == 2: # Unrestricted calculation Spin needs to be printed
                                            if ST[0][1] == 0:
                                                spin_init = "a" # spin alpha to print in the table
                                            elif ST[0][1] == 1:
                                                spin_init = "b" # spin beta to print in the table
                                            else:
                                                spin_init = "" # unrecognised spin
                                            if ST[1][1] == 0:
                                                spin_end = "a" # spin alpha to print in the table
                                            elif ST[1][1] == 1:
                                                spin_end = "b" # spin beta to print in the table
                                            else:
                                                spin_end = "" # unrecognised spin
                                            CIS += str(ST[0][0]+1) + spin_init +"-" + str(ST[1][0]+1) + spin_end +" (" + str(coeff) + ") "
                                        if len(homo_ind) == 1: # Restricted calculation Spin is omitted
                                            CIS += str(ST[0][0]+1) + "-" + str(ST[1][0]+1) + "(" + str(coeff) + "); "
                                # select the excited states when there is more than 20 calculated excited states. based on oscillator strength and rotational strength
                                if (td_selection == 0) or ((td_selection == 1) and ((j < 5) or \
                                                           (json_list[i]["results"]["excited_states"]["et_oscs"][j] > 0.1) or \
                                                           ((etr_i == "N/A") or (abs(etr_i) > 10.)))) : 
                                    td_tabu.add_row([(1 + j),
                                                     json_list[i]["results"]["excited_states"]["et_sym"][j], 
                                                     "%d " % et_nm[j] ,
                                                     "%d " % et_energies[j], 
                                                     "%.3f" % json_list[i]["results"]["excited_states"]["et_oscs"][j],
                                                     "%.1f" %  etr_i, 
                                                     # Printing only transitions over 5%
                                                     "%s" %  CIS 
                                                      ])                           
                            td_tabu.add_hline()                    
                    else:
                        with doc.create(Tabular('rrrrrrrrrp{6cm}')) as td_tabu :
                            if rnbExci < 21 :
                                row_cells = [MultiColumn(10, align='c', 
                                                         data="Table. Results concerning the calculated mono-electronic excitations.")]
                                td_selection = 0                               
                            else : # select the excited states when there is more than 20 calculated excited states. 
                                row_cells = [MultiColumn(10, align='c', 
                                                         data="Table. First five calculated mono-electronic excitations and those with f > 0.1 or R > 10."
                                                         )]
                                td_selection = 1                               
                            td_tabu.add_row(row_cells)
                            td_tabu.add_row([ "E.S.", "Symmetry", " nm ", NoEscape(r"cm$^{-1}$") , 
                                             italic("f"), "R", NoEscape(r"$\Lambda$"), NoEscape(r"d$_{CT}$"),  NoEscape(r"q$_{CT}$"), "Excitation description : initial OM - ending OM (% if > 5%)"])
                            td_tabu.add_hline()
                            for j in range(rnbExci) :
                                try : etr_i = json_list[i]["results"]["excited_states"]["et_rot"][j]
                                except KeyError :
                                    etr_i = 0. 
                                trans = json_list[i]["results"]["excited_states"]["et_transitions"][j]
                                # Form the string description of the escitation. Based on MO init -> MO end (%coeff)
                                CIS = " "
                                for subtrans, ST in enumerate(trans):
                                    coeff = int(ST[2]**2*100)
                                    if coeff > 5. : 
                                        if len(homo_ind) == 2: # Unrestricted calculation Spin needs to be printed
                                            if ST[0][1] == 0:
                                                spin_init = "a" # spin alpha to print in the table
                                            elif ST[0][1] == 1:
                                                spin_init = "b" # spin beta to print in the table
                                            else:
                                                spin_init = "" # unrecognised spin
                                            if ST[1][1] == 0:
                                                spin_end = "a" # spin alpha to print in the table
                                            elif ST[1][1] == 1:
                                                spin_end = "b" # spin beta to print in the table
                                            else:
                                                spin_end = "" # unrecognised spin
                                            CIS += str(ST[0][0]+1) + spin_init +"-" + str(ST[1][0]+1) + spin_end +" (" + str(coeff) + ") "
                                        if len(homo_ind) == 1: # Restricted calculation Spin is omitted
                                            CIS += str(ST[0][0]+1) + "-" + str(ST[1][0]+1) + "(" + str(coeff) + "); "
                                # select the excited states when there is more than 20 calculated excited states. based on oscillator strength and rotational strength
                                if (td_selection == 0) or ((td_selection == 1) and ((j < 5) or \
                                                           (json_list[i]["results"]["excited_states"]["et_oscs"][j] > 0.1) or \
                                                           ((etr_i == "N/A") or (abs(etr_i) > 10.)))) : 
                                    td_tabu.add_row([(1 + j),
                                                     json_list[i]["results"]["excited_states"]["et_sym"][j], 
                                                     "%d " % et_nm[j] ,
                                                     "%d " % et_energies[j], 
                                                     "%.3f" % json_list[i]["results"]["excited_states"]["et_oscs"][j],
                                                     "%.1f" %  etr_i, 
                                                     "%.2f" %  json_list[i]["results"]["excited_states"]["Tozer_lambda"][j],
                                                     "%.2f" %  json_list[i]["results"]["excited_states"]["d_ct"][j],
                                                     "%.2f" %  json_list[i]["results"]["excited_states"]["q_ct"][j],
                                                     # Printing only transitions over 5%
                                                     "%s" %  CIS 
                                                      ])
                               
                            td_tabu.add_hline()
                    doc.append(NoEscape(r'\end{center}'))

        # UV visible Absorption and Circular dischroism plots
        nomPng3 = "img-UV-Abso-Spectrum.png"
        if (not os.path.isfile(nomPng3)) :
            print("No PNG named "+nomPng3+" found. The spectrum can not be added to the report.\n")
        else:
            figure_one_col(doc, nomPng3, taillePng="10cm", 
                  caption="Calculated UV visible Absorption spectrum with a gaussian broadening (FWHM = 3000 cm-1)")
    
        nomPng4 = "img-UV-CD-Spectrum.png"
        if (not os.path.isfile(nomPng4)) :
            print("No PNG named "+nomPng4+" found. The spectrum can not be added to the report.\n")
        else:
            figure_one_col(doc, nomPng4, taillePng="10cm", 
                  caption="Calculated Circular Dichroism spectrum with a gaussian broadening (FWHM = 3000 cm-1)")
 
        # figures not available in text report type
        if report_type != 'text':

            # figure with EDD
            nomPng = "img-EDD-S1.png"
            nomPng_cam2 = "img-EDD-S1_cam2.png"                                                        
            nomPng2 = "img-EDD-S2.png"
            nomPng2_cam2 = "img-EDD-S2_cam2.png"                                                        
            if (os.path.isfile(nomPng)) :
                if (os.path.isfile(nomPng_cam2)) :
                    figure_two_col(doc, nomPng, nomPng_cam2, caption="Representation of the Electron Density Difference (S1-S0) from two points of view.")
                    if (os.path.isfile(nomPng2)) :
                        if (os.path.isfile(nomPng2_cam2)) :
                            figure_two_col(doc, nomPng2, nomPng2_cam2, caption="Representation of the Electron Density Difference (S2-S0) from two points of view.")
                elif (os.path.isfile(nomPng2)) :
                    figure_two_col(doc, nomPng, nomPng2, caption="Representation of the Electron Density Difference (S1-S0 left) and (S2-S0 right). The excited electron and the hole regions are indicated by respectively blue and white surfaces.")
            else:
                nomPng = "img-EDD-1.png"
                nomPng_cam2 = "img-EDD-1_cam2.png"
                nomPng2 = "img-EDD-2.png"
                nomPng2_cam2 = "img-EDD-2_cam2.png"
                if (os.path.isfile(nomPng)) :
                    if (os.path.isfile(nomPng_cam2)) :
                        figure_two_col(doc, nomPng, nomPng_cam2, caption="Representation of the Electron Density Difference (ES1-GS) from two points of view.")
                        if (os.path.isfile(nomPng2)) :
                            if (os.path.isfile(nomPng2_cam2)) :
                                figure_two_col(doc, nomPng2, nomPng2_cam2, caption="Representation of the Electron Density Difference (ES2-GS) from two points of view.")
                    elif (os.path.isfile(nomPng2)) :
                        figure_two_col(doc, nomPng, nomPng2, caption="Representation of the Electron Density Difference (ES1-GS left) and (ES2-GS right). The excited electron and the hole regions are indicated by respectively blue and white surfaces.")

        # Specific OPT_ES report tables 
        for i,jsonfile in enumerate(json_list):          
            #TD emission calculation results :                
            if job_types[i] == ['OPT_ES'] :                        
                j =str(i+1)
                #res_table.add_row(["Optimization of Time-dependent excited state specific results", " " , " "])
                emi_state = [int(s) for s in json_list[i]["metadata"]["log_file"] if s.isdigit()][0] 
                emi_index = emi_state-1
                try : emi_energy = json_list[i]["results"]["excited_states"]["et_energies"][emi_index]
                except KeyError :
                    emi_energy = 0.0
                # Conversion of wavenumbers to nm    
                et_nm = [nm_to_wnb / emi_energy]
                rnbExci = len([emi_energy])                            
                if rnbExci != 0 and emi_energy != 0.0:
                    doc.append(NoEscape(r'\begin{center}'))
                    # 2 kind of table including the charge transfer data when discretization is done (SI and Full)    
                    if report_type == 'text':
                        with doc.create(Tabular('rrrrrrp{6cm}')) as tableau :
                            row_cells = [MultiColumn(7, align='c', 
                                                     data="Table. Results concerning the calculated mono-electronic optimization excitation")]
                            tableau.add_row(row_cells)
                            tableau.add_row([ "E.S.", "Symmetry", " nm ", NoEscape(r"cm$^{-1}$") , 
                                             italic("f"), "R", "Excitation description in %"])
                            tableau.add_hline()
                            try : etr_i = json_list[i]["results"]["excited_states"]["et_rot"][emi_index]
                            except KeyError :
                                etr_i = "N/A" 
                            trans = json_list[i]["results"]["excited_states"]["et_transitions"][emi_index]
                            # Form the string description of the escitation. Based on MO init -> MO end (%coeff)
                            CIS = " "
                            for subtrans, ST in enumerate(trans):
                                coeff = int(ST[2]**2*100)
                                if len(homo_ind) == 2: # Unrestricted calculation Spin needs to be printed
                                    if ST[0][1] == 0:
                                        spin_init = "a" # spin alpha to print in the table
                                    elif ST[0][1] == 1:
                                        spin_init = "b" # spin beta to print in the table
                                    else:
                                        spin_init = "" # unrecognised spin
                                    if ST[1][1] == 0:
                                        spin_end = "a" # spin alpha to print in the table
                                    elif ST[1][1] == 1:
                                        spin_end = "b" # spin beta to print in the table
                                    else:
                                        spin_end = "" # unrecognised spin
                                    CIS += str(ST[0][0]+1) + spin_init +"-" + str(ST[1][0]+1) + spin_end +" (" + str(coeff) + ") "
                                if len(homo_ind) == 1: # Restricted calculation Spin is omitted
                                    CIS += str(ST[0][0]+1) +"->" + str(ST[1][0]+1) + " (" + str(coeff) + ") "
                            tableau.add_row([(2),
                                             json_list[i]["results"]["excited_states"]["et_sym"][emi_index], 
                                             "%d " % et_nm[emi_index] ,
                                             "%d " % emi_energy, 
                                             "%.3f" % json_list[i]["results"]["excited_states"]["et_oscs"][emi_index],
                                             "%s" %  etr_i, #"%.3f" % etr_i, ToDo NOT working when et rot  = N/A
                                              # trying to reduce CIS size size it can too large too fit in the page
                                             "%s" %  CIS 
                                              ])
                            tableau.add_hline()                   
                    else:
                        with doc.create(Tabular('rrrrrrrrrp{6cm}')) as tableau :
                            row_cells = [MultiColumn(10, align='c', 
                                                     data="Table. Results concerning the calculated mono-electronic optimization excitation")]
                            tableau.add_row(row_cells)
                            tableau.add_row([ "E.S.", "Symmetry", " nm ", NoEscape(r"cm$^{-1}$") , 
                                             italic("f"), "R", NoEscape(r"$\Lambda$"), NoEscape(r"d$_{CT}$"),  NoEscape(r"q$_{CT}$"), "Excitation description in %"])
                            tableau.add_hline()
                            try : etr_i = json_list[i]["results"]["excited_states"]["et_rot"][emi_index]
                            except KeyError :
                                etr_i = "N/A" 
                            trans = json_list[i]["results"]["excited_states"]["et_transitions"][emi_index]
                            # Form the string description of the escitation. Based on MO init -> MO end (%coeff)
                            CIS = " "
                            for subtrans, ST in enumerate(trans):
                                coeff = int(ST[2]**2*100)
                                if len(homo_ind) == 2: # Unrestricted calculation Spin needs to be printed
                                    if ST[0][1] == 0:
                                        spin_init = "a" # spin alpha to print in the table
                                    elif ST[0][1] == 1:
                                        spin_init = "b" # spin beta to print in the table
                                    else:
                                        spin_init = "" # unrecognised spin
                                    if ST[1][1] == 0:
                                        spin_end = "a" # spin alpha to print in the table
                                    elif ST[1][1] == 1:
                                        spin_end = "b" # spin beta to print in the table
                                    else:
                                        spin_end = "" # unrecognised spin
                                    CIS += str(ST[0][0]+1) + spin_init +"-" + str(ST[1][0]+1) + spin_end +" (" + str(coeff) + ") "
                                if len(homo_ind) == 1: # Restricted calculation Spin is omitted
                                    CIS += str(ST[0][0]+1) +"->" + str(ST[1][0]+1) + " (" + str(coeff) + ") "
                            tableau.add_row([(2),
                                             json_list[i]["results"]["excited_states"]["et_sym"][emi_index], 
                                             "%d " % et_nm[emi_index] ,
                                             "%d " % emi_energy, 
                                             "%.3f" % json_list[i]["results"]["excited_states"]["et_oscs"][emi_index],
                                             "%s" %  etr_i, #"%.3f" % etr_i, ToDo NOT working when et rot  = N/A
                                             "%.2f" %  json_list[i]["results"]["excited_states"]["Tozer_lambda"][emi_index],
                                             "%.2f" %  json_list[i]["results"]["excited_states"]["d_ct"][emi_index],
                                             "%.2f" %  json_list[i]["results"]["excited_states"]["q_ct"][emi_index],
                                             # trying to reduce CIS size size it can too large too fit in the page
                                             "%s" %  CIS 
                                              ])
                            tableau.add_hline()
                    doc.append(NoEscape(r'\end{center}'))  

        # UV visible Emission and Circular dischroism plots
        nomPng3 = "img-UV-Emi-Spectrum.png"
        if (not os.path.isfile(nomPng3)) :
            print("No PNG named "+nomPng3+" found. The spectrum can not be added to the report.\n")
        else:
            figure_one_col(doc, nomPng3, taillePng="10cm", 
                  caption="Calculated UV visible Emission spectrum with a gaussian broadening (FWHM = 3000 cm-1)")
    
        nomPng4 = "img-UV-CD-Emi-Spectrum.png"
        if (not os.path.isfile(nomPng4)) :
            print("No PNG named "+nomPng4+" found. The spectrum can not be added to the report.\n")
        else:
            figure_one_col(doc, nomPng4, taillePng="10cm", 
                  caption="Calculated Circular Dichroism Emission spectrum with a gaussian broadening (FWHM = 3000 cm-1)")

        if report_type != 'text':
            # figure with EDD for emission
            nomPng = "img-emi-EDD-S1.png"
            if (os.path.isfile(nomPng)) :
                figure_one_col(doc, nomPng, taillePng="10cm", 
                      caption="Representation of the Electron Density Difference (S1-GS) after optimization of the excited state. The excited electron and the hole regions are indicated by respectively white and blue surfaces to ease comparison with the corresponding absorption transition.")
            
        ######## Table of atomic coordinates 
        #doc.append(NoEscape(r'\clearpage'))
        atomic = data_ref["results"]["geometry"]["elements_3D_coords_converged"]
        oxtrf ,oytrf, oxtrd ,oytrd = ('N/A','N/A','N/A','N/A')

        doc.append(NoEscape(r'\begin{footnotesize}'))        
        doc.append(NoEscape(r'\begin{center}'))
        with doc.create(LongTable('p{0.5cm}rrrrp{0.5cm}')) as tableau :
            row_cells = [MultiColumn(6, align='c', data='Table. Converged cartesian atomic coordinates in Angstroms')]
            tableau.add_row(row_cells)
            tableau.add_row(["","Atom", 
                             MultiColumn(1, align='c', data='X'),
                             MultiColumn(1, align='c', data='Y'),
                             MultiColumn(1, align='c', data='Z'),
                             ""])
            tableau.add_hline()           
            atoms = np.array(json_list[i]["results"]["geometry"]["elements_3D_coords_converged"]).reshape((-1, 3))
            for j, a in enumerate(atoms):
                tableau.add_row(["",PeriodicTable().element[json_list[i]['molecule']["atoms_Z"][j]],
                                 "%.4f" % a[0], "%.4f" % a[1], "%.4f" % a[2],"" ])
            tableau.add_hline()
            
        doc.append(NoEscape(r'\end{center}'))
        doc.append(NoEscape(r'\end{footnotesize}'))        
    
    #####################################################################
    #                                                                   #
    ## 3. compilation LaTeX                                             #
    #                                                                   #
    #####################################################################
    
    # on compile
    # on previent si le fichier PDF est present ou pas
    # par defaut dans pylatex tout ce qui concerne latex est efface
    
    # doc.generate_pdf(rapFile, clean_tex=True) # comportement en routine, avec False en mode dev/debug
    # OK sans SVG doc.generate_pdf(rapFile, clean_tex=False)
    # pas de chance !! doc.generate_pdf(rapFile, clean_tex=False,compiler="pdflatex  --shell-escape")
    
    
    texFile = rapFile + ".tex"
    if (os.path.isfile(texFile)) :
        os.remove(texFile)
    
    pdfFile = rapFile + ".pdf"
    if (os.path.isfile(pdfFile)) :
        os.remove(pdfFile)
    
    doc.generate_tex(rapFile)
    cmd = "pdflatex  --shell-escape " + rapFile
    
    # si cleanMode = "--clean" on redirige vers /dev/null
    if mode=="clean" :
       cmd += " > /dev/null"
    
    # compilation LaTeX
    
    os.system(cmd)
    
    # un peu de nettoyage si cleanMode = "--clean"
    
    if mode=="clean" :
       if os.path.isfile(rapFile+'.aux') :
          os.remove(rapFile+'.aux')
       if os.path.isfile(rapFile+'.log') :
          os.remove(rapFile+'.log')
#       if os.path.isfile(rapFile+'.tex') :
#          os.remove(rapFile+'.tex')
    
    # message de fin
    
    if (os.path.isfile(pdfFile)) :
       print('Report file is ' + rapFile + ".pdf")
    else :
       print('Probably a LateX error.')
