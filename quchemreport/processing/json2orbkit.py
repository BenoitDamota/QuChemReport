# Based on cclib parser python file of orbkit v1.0
# Adaptation to JSON data generated by scanlog

import numpy
import sklearn.preprocessing

from orbkit.qcinfo import QCinfo
from orbkit.orbitals import AOClass, MOClass
from orbkit.units import aa_to_a0, ev_to_ha
from orbkit.display import display
from orbkit.tools import l_deg, lquant, get_atom_symbol
from importlib import import_module

# added imports
# pickle for basis set information in JSON
from pickle import loads
# scipy.parse for mo_coeffs in JSON
import scipy.sparse

def convert_json(jData, all_mo=False, spin=None):
  '''Converts a JSON data created by scanlog to an instance of
  orbkit's QCinfo class.

  **Parameters:**
  
    jData : class
      Contains the input JSON data created by scanlog.
    all_mo : bool, optional
      If True, all molecular orbitals are returned.
    spin : {None, 'alpha', or 'beta'}, optional
      If not None, returns exclusively 'alpha' or 'beta' molecular orbitals.


  **Returns:**

    qc (class QCinfo) with attributes geo_spec, geo_info, ao_spec, mo_spec, etot :
          See :ref:`Central Variables` for details.
  '''
  # Initialize the variables 
  qc = QCinfo()
  qc.ao_spec = AOClass([])
  qc.mo_spec = MOClass([])
  
  # Added lines to orbkit program for basis set and MO coeffs storage in JSON
  gbasis = loads(bytes(jData['comp_details']['general']['basis_set'], 'utf-8'))
  shape = (jData['results']['wavefunction']['MO_number_kept'],jData['comp_details']['general']['basis_set_size'])
  pre_mocoeffs = jData['results']['wavefunction']['MO_coefs']
  # Detexction od MO coeffs stored as sparse matrices with tuples or dense ones.
  if type(pre_mocoeffs[0]) is tuple:
    # Compatible for both restricted and unrestricted cases. TODO prepare tests with sparsed restricted, sparse unrestricted..
    mocoeffs = [numpy.asarray(scipy.sparse.csr_matrix(tuple([numpy.asarray(d) for d in sp_mat]), shape=shape).todense()) for sp_mat in pre_mocoeffs]
#    if len(jData['results']['wavefunction']['MO_energies']) == 1:
#      mocoeffs = [numpy.asarray(scipy.sparse.csr_matrix(tuple([numpy.asarray(d) for d in pre_mocoeffs[0]]), shape=shape).todense())]    
#    else:
#      mocoeffs = [numpy.asarray(scipy.sparse.csr_matrix(tuple([numpy.asarray(d) for d in pre_mocoeffs[0]]), shape=shape).todense()), numpy.asarray(scipy.sparse.csr_matrix(tuple([numpy.asarray(d) for d in pre_mocoeffs[1]]), shape=shape).todense())]
  else:
    mocoeffs = [numpy.asarray(dense_mat) for dense_mat in pre_mocoeffs]
    # test renomalisation l1 de OM Gaussian. See if discretization by orbkit yield beter electron count and norms
    # L1 norm is similar to the gaussian log. L2 norm is really normalized to 1 and not near 0.5. Should it be L2/2 for restricted ? 
    # In both cases the normalization after discretization is worse. 
    #mocoeffs_norm = [sklearn.preprocessing.normalize(dense_mat, norm='l2', copy=False)/numpy.sqrt(2) for dense_mat in mocoeffs]
    #mocoeffs = mocoeffs_norm   
 
  # Converting all information concerning atoms and geometry
  qc.geo_spec = numpy.array(jData['results']['geometry']['elements_3D_coords_converged']).reshape((-1,3)) * aa_to_a0
  for ii in range(jData["molecule"]['nb_atoms']):
    symbol = get_atom_symbol(atom=jData["molecule"]['atoms_Z'][ii])
    qc.geo_info.append([symbol,str(ii+1),str(jData["molecule"]['atoms_Z'][ii])])
  
  # Convert geo_info and geo_spec to numpy.ndarrays
  qc.format_geo()
  
  # Converting all information about atomic basis set
  for ii in range(jData["molecule"]['nb_atoms']):
    for jj in range(len(gbasis[ii])):
      pnum = len(gbasis[ii][jj][1])
      qc.ao_spec.append({'atom': ii,
                  'type': str(gbasis[ii][jj][0]).lower(),
                  'pnum':  pnum,
                  'coeffs': numpy.zeros((pnum, 2))
                  })
      for kk in range(pnum):
        qc.ao_spec[-1]['coeffs'][kk][0] = gbasis[ii][jj][1][kk][0]
        qc.ao_spec[-1]['coeffs'][kk][1] = gbasis[ii][jj][1][kk][1]

  # TODO test 6D 7F basis sets
  if "ao_names" in jData['comp_details']['general']:
    # Reconstruct exponents list for ao_spec
    aonames = jData['comp_details']['general']['ao_names']

    # renaming ORCA d orbitals to Gaussian style
    # TODO: f orbitals
    if jData["comp_details"]["general"]["package"] == 'ORCA':
      for i, aoname in enumerate(aonames) :
        aonames[i] = aonames[i].replace('DZ2', 'D 0')
        aonames[i] = aonames[i].replace('DXZ', 'D+1')
        aonames[i] = aonames[i].replace('DYZ', 'D-1')
        aonames[i] = aonames[i].replace('DX2Y2', 'D+2')
        aonames[i] = aonames[i].replace('DXY', 'D-2')

    cartesian_basis = True
    for i in aonames:
      if '+' in i or '-' in i:
        cartesian_basis = False

    if not cartesian_basis:
        qc.ao_spec.spherical = True
    
    count = 0
    for i,ao in enumerate(qc.ao_spec):
      l = l_deg(lquant[ao['type']],cartesian_basis=cartesian_basis)


      # ------------------------------- TEST
      #if l == 6:
      #  l = 5



      if cartesian_basis:
        ao['lxlylz'] = []
      else:
        ao['lm'] = []
      for ll in range(l):
        if cartesian_basis:
          ao['lxlylz'].append((aonames[count].lower().count('x'),
                               aonames[count].lower().count('y'),
                               aonames[count].lower().count('z')))
        else:
          m = aonames[count].lower().split('_')[-1]
          m = m.replace('+',' +').replace('-',' -').replace('s','s 0').split(' ') 
          p = 'yzx'.find(m[0][-1])
          if p != -1:
            m = p - 1
          else:
            m = int(m[-1])
          ao['lm'].append((lquant[ao['type']],m))
        count += 1
  
  # Converting all information about molecular orbitals
  ele_num = numpy.sum(jData["molecule"]['atoms_Z']) - numpy.sum(jData['comp_details']['general']['core_electrons_per_atoms']) - jData["molecule"]['charge']
  ue = (jData["molecule"]['multiplicity']-1)
  
  # Check for natural orbitals and occupation numbers
  is_natorb = False
  # TODO No natural orbitals in JSON
  #if hasattr(ccData,'nocoeffs'):
  #  if not hasattr(ccData,'nooccnos'):
  #    raise IOError('There are natural orbital coefficients (`nocoeffs`) in the cclib' + 
  #                  ' ccData, but no natural occupation numbers (`nooccnos`)!')
  #  is_natorb = True
  
  restricted = (len(jData['results']['wavefunction']['MO_energies']) == 1)
  if spin is not None:
    if spin != 'alpha' and spin != 'beta':
      raise IOError('`spin=%s` is not a valid option' % spin)
    elif restricted:
      raise IOError('The keyword `spin` is only supported for unrestricted calculations.')
    else:
      qc.mo_spec.spinpola
      display('Converting only molecular orbitals of spin %s.' % spin)
  
  sym = {}
  if restricted:
    add = ['']
    orb_sym = [None]	
  else:
    add = ['_a','_b']      
    orb_sym = ['alpha','beta']
  
  nmo = jData['results']['wavefunction']['MO_number_kept'] if 'MO_number_kept' in jData['results']['wavefunction'] else len(mocoeffs[0])  
  for ii in range(nmo):    
    for i,j in enumerate(add):
      if 'MO_sym' in jData['results']['wavefunction']:
        a = '%s%s' % (jData['results']['wavefunction']['MO_sym'][i][ii],j)
      else:
        a = '%s%s' % ('A',j)
      if a not in sym.keys(): sym[a] = 1
      else: sym[a] += 1
      if is_natorb:
        occ_num = ccData.nooccnos[ii]
      elif not restricted:
        occ_num = 1.0 if ii <= jData['results']['wavefunction']['homo_indexes'][i] else 0.0
      elif ele_num > ue:
        occ_num = 2.0
        ele_num -= 2.0
      elif ele_num > 0.0 and ele_num <= ue: 
        occ_num = 1.0
        ele_num -= 1.0
        ue -= 1.0
      else:
        occ_num = 0.0
        
      qc.mo_spec.append({'coeffs': (mocoeffs[i])[ii],
              'energy': jData['results']['wavefunction']['MO_energies'][i][ii]*ev_to_ha,
              'occ_num': occ_num,
              'sym': '%d.%s' %(sym[a],a)
              })
      if orb_sym[i] is not None:
        qc.mo_spec[-1]['spin'] = orb_sym[i]
        if spin is not None and spin != orb_sym[i]:
          del qc.mo_spec[-1]
  
  # Use default order for atomic basis functions if aonames is not present
  if 'ao_names' not in jData['comp_details']['general']:
    display('The attribute `aonames` is not present in the parsed data.')
    display('Using the default order of basis functions.')
    
    # Check which basis functions have been used
    c_cart = sum([l_deg(l=ao['type'], cartesian_basis=True) for ao in qc.ao_spec])
    c_sph = sum([l_deg(l=ao['type'], cartesian_basis=False) for ao in qc.ao_spec])
    
    c = qc.mo_spec.get_coeffs().shape[-1]
    if c != c_cart and c == c_sph: # Spherical basis
      qc.ao_spec.set_lm_dict(p=[0,1])
    elif c != c_cart:
      display('Warning: The basis set type does not match with pure spherical ' +
              'or pure Cartesian basis!') 
      display('Please specify qc.ao_spec["lxlylz"] and/or qc.ao_spec["lm"] by your self.')
  
  # Are all MOs requested for the calculation? 
  if not all_mo:
    for i in range(len(qc.mo_spec))[::-1]:
      if qc.mo_spec[i]['occ_num'] < 0.0000001:
        del qc.mo_spec[i]

  qc.mo_spec.update()
  qc.ao_spec.update()
  return qc
