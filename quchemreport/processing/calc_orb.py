#! /usr/bin/env python2.7
## -*- encoding: utf-8 -*-



## Functions for calculating molecular orbitals and electron density differences.

from quchemreport.utils.units import A_to_a0, ea0_to_D, pm_to_a0, eV_to_Eh
from orbkit import core
import numpy as np

## Patched version of orbkit.read to read a json
from quchemreport.processing import json2orbkit
#from sys import exit


## Get grid parameters and initialize grid
def _init_ORB_grid(data, grid_par=-6, over_s=7):
    u"""Initializes ORBKIT's grid and returns necessary data for visualization.

    **Parameters:**
      data : dict
    QCinfo instance representing the molecule.
      grid_par : int
    Parameter controlling grid. If positive or zero, it specifies number of points; otherwise it specifies the resolution in inverse atomic units.
      over_s : int|float
    Oversizing, to be tuned

    **Returns**
      X, Y, Z
    Meshgrid (as returned by numpy.mgrid) for positioning the voxels.
    """

    from orbkit import grid

    ## Reinitialization of the grid
    grid.is_initialized=False
    
    ## Spacing/Number of points
    if grid_par > 0:
        grid.N_ = [grid_par]*3
    elif grid_par == 0:
        grid.N_ = [80]*3
    else:
        grid.delta_ = [1.0/(-grid_par)]*3
    
    grid.max_ = np.amax(data.geo_spec, axis=0) + over_s
    grid.min_ = np.amin(data.geo_spec, axis=0) - over_s
    
    grid.adjust_to_geo(data,extend=over_s,step=grid.delta_[0])
    grid.init(force=True)

    ## The meshgrid MUST be generated in this manner,
    ## in order to be maximally consistent with ORBKIT
    ## which uses numpy.arange to generate its grid
    ## (i.e. start:stop+step:step)
    X, Y, Z = np.mgrid[grid.min_[0] : grid.max_[0] + grid.delta_[0] : grid.delta_[0],
                           grid.min_[1] : grid.max_[1] + grid.delta_[1] : grid.delta_[1],
                           grid.min_[2] : grid.max_[2] + grid.delta_[2] : grid.delta_[2]]
    ## NOTICE: numpy.arange does not return consistent results if step is a float,
    ## specifically if (stop - start)/step overflows, resulting in
    ## arange(start, stop, step)[-1] > stop

    return X, Y, Z



def _alt_init_ORB_grid(data, N, D):
    from orbkit import grid

    grid.N_ = np.array(N)
    grid.delta_ = np.array(D)

    T = grid.N_*grid.delta_
    P = np.mean(data.geo_spec, axis=0)

    grid.min_ = P - T/2
    grid.max_ = P + T/2

    grid.init()

    X, Y, Z = np.mgrid[grid.min_[0] : grid.max_[0] + grid.delta_[0] : grid.delta_[0],
                           grid.min_[1] : grid.max_[1] + grid.delta_[1] : grid.delta_[1],
                           grid.min_[2] : grid.max_[2] + grid.delta_[2] : grid.delta_[2]]

    return X, Y, Z



## Calculations
def MO(j_data, MO_list, grid_par=-6):
    u"""Calculates the voxels representing the requested molecular orbitals of a molecule.

    ** Parameters **
      j_data : dict
    Data on the molecule, deserialized from the scanlog format.
      MO_list : list(str) or list(int)
    A list containing either:
      - integers designating the molecular orbitals (starting from 1)
      - strings designating the molecular orbitals either through:
        - keywords (e.g. "homo", "lumo")
        - ranges (e.g. "homo-1:lumo+2")
        - symmetries (e.g. "5.A")
      grid_par : int, optional
    Governs the grid to be used for the voxels.
      - If positive, it indicates the number of points in all 3 dimensions.
      - If zero, it indicates the default number of points (80).
      - If negative, it indicates the resolution, in (A.U.)^-1.

    ** Returns **
      out : list(numpy.ndarray)
    List of numpy.ndarrays, each one containing the values of the probability amplitude of a single molecular orbital at each voxel of the grid.
      X, Y, Z : numpy.ndarray
    Meshgrids (as generated by numpy.mgrid) required for positioning the voxel values contained in out.
    """

    ## Prepare data for ORBKIT
    qc = json2orbkit.convert_json(j_data, all_mo=True)
    X, Y, Z = _init_ORB_grid(qc, grid_par=grid_par)

    ## Get list of orbitals
    qc.mo_spec = json2orbkit.mo_select(qc.mo_spec, MO_list)["mo_spec"]

    ## Calculate
    out = core.rho_compute(qc, calc_mo=True, numproc=4)

    return out, X, Y, Z



def _density_difference_MOs(transitions):
    u"""Determines the molecular orbitals involved in electron transitions.

    ** Parameters **
      transitions : list
    Structured list, each element containing the following data for a single transition:
      - Initial and final states:
        - Molecular orbital
        - Spin
      - Coefficient

    ** Returns **
      MO_set : set
    The set of molecular orbitals to calculate
      tab : dict
    A translation dictionary mapping the molecular orbitals to indices.
    """

    ## Get all MOs involved in transitions
    MO_list = [STT[0] for T in transitions for ST in T for STT in ST[:2]]
    # Get all unique MO involved
    MO_set = set(MO_list)
    ## The dictionary is needed because the MO numbers do not correspond
    ## to their indices in the output of rho_compute, and we can only access
    ## them through indices (assuming ORBKIT conserves the order of the MO
    ## numbers in qc.mo_spec)
    tab = dict([(MO, i) for i, MO in enumerate(MO_set)])

    return MO_set, tab



def TD(j_data, transitions, grid_par=-6):
    u"""Calculates diverse data on the requested transitions of a molecule.

    ** Parameters **
      j_data : dict
    Data on the molecule, as deserialized from the scanlog format.
      transitions : list
    A list of integers designating the transitions to consider (starting from 0)
      grid_par : int, optional
    Governs the grid to be used for voxel data.
      - If positive, it indicates the number of points in all 3 dimensions.
      - If zero, it indicates the default number of points (80).
      - If negative, it indicates the resolution, in Á^-1.

    ** Returns ** 
      out: list(tuple)
    List of tuples containing:
     - sequences of voxels representing the density difference;
     - Tozer (covering) coefficient of the MOs;
     - A tuple containing:
       - The electron displacement, in picometres
       - The transferred charge
       - The dipole moment, in Debye
       - The positions of the positive and negative barycenters, respectively, in A.U.

      X, Y, Z : numpy.ndarray
    Meshgrids (as generated by numpy.mgrid), required for placing the voxels contained in out.
    """

    ## To save time, the calculation is done in two phases:

    ## 1. Get all MOs involved in transitions and calculate them once
    MO_set, tab = _density_difference_MOs(transitions)

    MOs, X, Y, Z = MO(j_data, [str(Orb_index + 1) for Orb_index in MO_set], grid_par=grid_par)

    dx, dy, dz = (X[10,0,0] - X[9,0,0]), (Y[0,10,0] - Y[0,9,0]), (Z[0,0,10] - Z[0,0,9])
    d3r = dx*dy*dz
    print("Element of volume :", d3r)

    ## 2. Combine MOs according to info in `et_transitions`
    out = []
    for i, T in enumerate(transitions):
        vox_data = np.zeros(MOs[0].shape)
        tozer = 0
        for j, ST in enumerate(T):
            print("Calculating transition {}.{}".format(i, j))
            ## Dp_i = S_j(C_ij**2*(MO2_ij**2 - MO1_ij**2))
            MO_end, MO_start = MOs[tab[ST[1][0]]], MOs[tab[ST[0][0]]]
            rho_end, rho_start = np.square(MO_end), np.square(MO_start)
            vox_data += ST[2]**2*(rho_end - rho_start)

            ## Tozer_i = S_j(C_ij**2*(|MO2_ij|*|MO1_ij|))
            abs_MO_end, abs_MO_start = np.abs(MO_end), np.abs(MO_start)
            tozer += ST[2]**2*np.sum(abs_MO_end*abs_MO_start)*d3r

        P_i, N_i = vox_data > 0.0, vox_data < 0.0

        DDp, Xp, Yp, Zp = vox_data[P_i], X[P_i], Y[P_i], Z[P_i]
        DDn, Xn, Yn, Zn = vox_data[N_i], X[N_i], Y[N_i], Z[N_i]
        Qctp, Qctn = np.sum(DDp)*d3r, np.sum(DDn)*d3r
        Pp = np.array([np.sum(DDp*Xp)*d3r/Qctp + dx/2.0, np.sum(DDp*Yp)*d3r/Qctp + dy/2.0, np.sum(DDp*Zp)*d3r/Qctp + dz/2.0])
        Pn = np.array([np.sum(DDn*Xn)*d3r/Qctn + dx/2.0, np.sum(DDn*Yn)*d3r/Qctn + dy/2.0, np.sum(DDn*Zn)*d3r/Qctn + dz/2.0])
        D = np.sqrt(np.sum(np.square(Pp - Pn)))
        Mu = D*Qctp/ea0_to_D

        out += [(vox_data, tozer, (D*pm_to_a0, Qctp, Mu, Pp, Pn))]

    return out, X, Y, Z



def Potential(j_data, grid_par=-6):
    u"""Calculates the electric potential difference for the molecule.

    ** Parameters **
      j_data : dict
    Data on the molecule, as deserialized from the scanlog format.
      grid_par : int, optional
    Governs the grid to be used for voxel data.
      - If positive, it indicates the number of points in all 3 dimensions.
      - If zero, it indicates the default number of points (80).
      - If negative, it indicates the resolution, in Á^-1.

    ** Returns **
      rho : numpy.ndarray
    The voxels containing the scalar values of the density.
      V : numpy.ndarray
    The voxels containing the scalar values of the potential.
      X, Y, Z : numpy.ndarray
    Meshgrids (as generated by numpy.mgrid), required for placing the voxels contained in rho and V.
    """

    qc = json2orbkit.convert_json(j_data)

    X, Y, Z = _init_ORB_grid(qc, grid_par=grid_par)

    dx, dy, dz = (X[10,0,0] - X[9,0,0]), (Y[0,10,0] - Y[0,9,0]), (Z[0,0,10] - Z[0,0,9])
    d3r = dx*dy*dz

    rho = core.rho_compute(qc, numproc=4)
    print("Rho : ", np.sum(rho)*d3r, "(", np.min(rho)," ... ", np.max(rho),")")
    print("d : ", dx, dy, dz)
    print("P0 : ", X[0,0,0], Y[0,0,0], Z[0,0,0])
    print("P1 : ", X[-1,0,0], Y[0,-1,0], Z[0,0,-1])
    P = np.array([X, Y, Z])

    ## The potential can be separated into two terms
    ## V_n, the contribution from nuclear charges (positive)
    V_n = np.zeros(rho.shape)
    for i in range(len(qc.geo_spec)):
        ## This currently works by:
        ## 1. reshaping the atom position triplet to the shape of the meshgrids
        ## 2. calculating the norm accross the three dimensions
        ## 3. propagating the meshgrid shape to the charge
        R = np.linalg.norm(P - qc.geo_spec[i].reshape((3,1,1,1)), axis=0)
        R[R < 0.005] = np.inf
        N_i = float(qc.geo_info[i,-1])/R
        V_n += N_i
        print("V_n (", qc.geo_info[i,0], qc.geo_info[i,-1], ") : (", np.min(N_i), ", ", np.max(N_i), ") (", np.argwhere(N_i > 250).size, ")")


    TIx, TIy, TIz = rho.shape
    Tx, Ty, Tz = X[-1,0,0] - X[0,0,0], Y[0,-1,0] - Y[0,0,0], Z[0,0,-1] - Z[0,0,0]


    ## V_r, the contribution from the electron density (negative)
    ## To avoid calculating the full volume integral,
    ## we consider rho as a kernel and apply it to
    ## the grid of inverse distances as though it
    ## were an image

    ## 1. Accumulate local potential
    V_e = np.ones(rho.shape)*rho

    ## Reverse rho, so that it is traversed in the
    ## same direction as the image matrix
    rho_r = rho[::-1,::-1,::-1].copy()

    ## 2. Extend grid
    X_, Y_, Z_ = np.mgrid[ dx*(1 - TIx) : dx*TIx : dx,
                           dy*(1 - TIy) : dy*TIy : dy,
                           dz*(1 - TIz) : dz*TIz : dz ]
    print("Potential shape :", P.shape)

    ## 3. Calculate distance grid
    D = np.linalg.norm(np.array([0,0,0]).reshape((3,1,1,1)) - np.array([X_,Y_,Z_]), axis=0)
    D[TIx - 1, TIy - 1, TIz - 1] = np.inf
    R = 1/D

    ## 4. Convolute
    for i in xrange(TIx):
        ie = i + TIx
        for j in xrange(TIy):
            je = j + TIy
            for k in xrange(TIz):
                V_e[i,j,k] += (rho_r * R[i:ie, j:je, k:k + TIz]).sum()

    #from scipy import signal as sg
    #V_e += sg.fftconvolve(R, rho, "valid")

    V_e *= d3r

    return rho, V_n - V_e, X, Y, Z

def Fukui(j_data_opt, j_data_sp, label=None, grid_par=-6):
    u"""Calculates the density differences/Fukui functions of the molecule.

    ** Parameters **
      j_data_opt : dict
    Data on the optimized molecule, as deserialized from the scanlog format.
          j_data_sp : dict
        Data on the optimized molecule, as deserialized from the scanlog format.
      grid_par : int, optional
    Governs the grid to be used for voxel data.
      - If positive, it indicates the number of points in all 3 dimensions.
      - If zero, it indicates the default number of points (80).
      - If negative, it indicates the resolution, in Á^-1.

         ** Returns **
           rho : numpy.ndarray
         The voxels containing the scalar values of the density.
           V : numpy.ndarray
         The voxels containing the scalar values of the potential.
           X, Y, Z : numpy.ndarray
         Meshgrids (as generated by numpy.mgrid), required for placing the voxels contained in rho and V.
        """
 
    qc_opt = json2orbkit.convert_json(j_data_opt)
    qc_sp = json2orbkit.convert_json(j_data_sp)
 ## Get all MOs involved in transitions
#    MO_list = [STT[0] for T in transitions for ST in T for STT in ST[:2]]
    # Get all unique MO involved
#    MO_set = set(MO_list)
    ## The dictionary is needed because the MO numbers do not correspond
    ## to their indices in the output of rho_compute, and we can only access
    ## them through indices (assuming ORBKIT conserves the order of the MO
    ## numbers in qc.mo_spec)
#    tab = dict([(MO, i) for i, MO in enumerate(MO_set)])
    X, Y, Z = _init_ORB_grid(qc_opt, grid_par=grid_par)
 
    dx, dy, dz = (X[10,0,0] - X[9,0,0]), (Y[0,10,0] - Y[0,9,0]), (Z[0,0,10] - Z[0,0,9])
    d3r = dx*dy*dz
 
    rho_opt = core.rho_compute(qc_opt, numproc=4)
    rho_sp = core.rho_compute(qc_sp, numproc=4)

    ## Calculation of the delta rho
    if j_data_sp["molecule"]["charge"] < 0 :
        delta_rho = np.subtract(rho_sp, rho_opt)
    elif  j_data_sp["molecule"]["charge"] > 0 :
        delta_rho = np.subtract(rho_opt, rho_sp)
            

    print("Rho : ", np.sum(rho_opt)*d3r, "(", np.min(rho_opt)," ... ", np.max(rho_opt),")")
    print("d : ", dx, dy, dz)
    print("P0 : ", X[0,0,0], Y[0,0,0], Z[0,0,0])
    print("P1 : ", X[-1,0,0], Y[0,-1,0], Z[0,0,-1])
    P = np.array([X, Y, Z])
         
    return delta_rho, X, Y, Z


def Fdual(j_data_opt, j_data_spplus, j_data_spminus, grid_par=-6):
      
    qc_opt = json2orbkit.convert_json(j_data_opt)
    qc_spplus = json2orbkit.convert_json(j_data_spplus)
    qc_spminus = json2orbkit.convert_json(j_data_spminus)

    X, Y, Z = _init_ORB_grid(qc_opt, grid_par=grid_par)

    dx, dy, dz = (X[10,0,0] - X[9,0,0]), (Y[0,10,0] - Y[0,9,0]), (Z[0,0,10] - Z[0,0,9])
    d3r = dx*dy*dz

    rho_opt = core.rho_compute(qc_opt, numproc=4)
    rho_spplus = core.rho_compute(qc_spplus, numproc=4)
    rho_spminus = core.rho_compute(qc_spminus, numproc=4)

    delta_rho_plus = np.subtract(rho_spplus, rho_opt)
    delta_rho_minus = np.subtract(rho_opt, rho_spminus)
    delta_rho_2 =  np.subtract(delta_rho_plus, delta_rho_minus)

    print("Rho : ", np.sum(rho_opt)*d3r, "(", np.min(rho_opt)," ... ", np.max(rho_opt),")")
    print("d : ", dx, dy, dz)
    print("P0 : ", X[0,0,0], Y[0,0,0], Z[0,0,0])
    print("P1 : ", X[-1,0,0], Y[0,-1,0], Z[0,0,-1])
    P = np.array([X, Y, Z])

    return delta_rho_2, X, Y, Z 


def CDFT_plus_Indices(j_data_opt, j_data_spplus):
    Eref = j_data_opt["results"]["wavefunction"]["total_molecular_energy"]
    Eplus = j_data_spplus["results"]["wavefunction"]["total_molecular_energy"]

    A = (Eref-Eplus)*eV_to_Eh

    OPT_charges = np.array(j_data_opt["results"]["wavefunction"]["Mulliken_partial_charges"])
    SPplus_charges = np.array(j_data_spplus["results"]["wavefunction"]["Mulliken_partial_charges"])
    fplus_lambda_mulliken = np.subtract(OPT_charges, SPplus_charges)
    
    OPT_charges = np.array(j_data_opt["results"]["wavefunction"]["Hirshfeld_partial_charges"])
    SPplus_charges = np.array(j_data_spplus["results"]["wavefunction"]["Hirshfeld_partial_charges"])
    fplus_lambda_hirshfeld = np.subtract(OPT_charges, SPplus_charges)

    return A, fplus_lambda_mulliken, fplus_lambda_hirshfeld
    

def CDFT_minus_Indices(j_data_opt, j_data_spminus):
    Eref = j_data_opt["results"]["wavefunction"]["total_molecular_energy"]
    Eminus = j_data_spminus["results"]["wavefunction"]["total_molecular_energy"]
    
    I = (Eminus-Eref)*eV_to_Eh

    OPT_charges = np.array(j_data_opt["results"]["wavefunction"]["Mulliken_partial_charges"])
    SPminus_charges = np.array(j_data_spminus["results"]["wavefunction"]["Mulliken_partial_charges"])
    fminus_lambda_mulliken = np.subtract(OPT_charges, SPminus_charges)

    OPT_charges = np.array(j_data_opt["results"]["wavefunction"]["Hirshfeld_partial_charges"])
    SPminus_charges = np.array(j_data_spminus["results"]["wavefunction"]["Hirshfeld_partial_charges"])
    fminus_lambda_hirshfeld = np.subtract(OPT_charges, SPminus_charges)

    return I, fminus_lambda_mulliken, fminus_lambda_hirshfeld
    
def CDFT_Indices(j_data_opt, j_data_spplus, j_data_spminus):

    """CDFT indices to be calculated :
            Electron affinity A
            Ionisation potential I
            Electronegativity Khi
            Hardness Eta
            Electrophilicity Omega
            Electron-flow DeltaN
            Condensed fukui (plus and minus)
            Condensed Dual Descriptor
            Condensed Omega (plus and minus, dual)"""

    A, fplus_lambda_mulliken, fplus_lambda_hirshfeld = CDFT_plus_Indices(j_data_opt, j_data_spplus)
    I, fminus_lambda_mulliken, fminus_lambda_hirshfeld = CDFT_minus_Indices(j_data_opt, j_data_spminus)

    Khi = (I+A)/2.
    Eta = I-A
    Omega = Khi*Khi/(2*Eta)
    DeltaN = Khi/Eta

 ## Calculations for the condensed fukui and condensed dual descriptor based on Mulliken and Hirshfeld charges 
    fdual_lambda_mulliken = np.subtract(fplus_lambda_mulliken, fminus_lambda_mulliken)
    fdual_lambda_hirshfeld = np.subtract(fplus_lambda_hirshfeld, fminus_lambda_hirshfeld)

    c_Omega_plus_mulliken = np.multiply(Omega, fplus_lambda_mulliken)
    c_Omega_minus_mulliken = np.multiply(Omega, fminus_lambda_mulliken)
    c_Omega_dual_mulliken = np.multiply(Omega, fdual_lambda_mulliken)

    c_Omega_plus_hirshfeld = np.multiply(Omega, fplus_lambda_hirshfeld)
    c_Omega_minus_hirshfeld = np.multiply(Omega, fminus_lambda_hirshfeld)
    c_Omega_dual_hirshfeld = np.multiply(Omega, fdual_lambda_hirshfeld)

    return A, I, Khi, Eta, Omega, DeltaN, fplus_lambda_mulliken, fminus_lambda_mulliken, fdual_lambda_mulliken, fplus_lambda_hirshfeld, fminus_lambda_hirshfeld, fdual_lambda_hirshfeld, c_Omega_plus_mulliken, c_Omega_minus_mulliken, c_Omega_dual_mulliken, c_Omega_plus_hirshfeld, c_Omega_minus_hirshfeld, c_Omega_dual_hirshfeld




    pass
